package net.colar.netbeans.fan.indexer;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;
import net.colar.netbeans.fan.FanUtilities;
import net.colar.netbeans.fan.indexer.model.FanDocument;
import net.jot.logger.JOTLoggerLocation;
import org.netbeans.api.java.platform.JavaPlatform;
import org.openide.filesystems.FileAttributeEvent;
import org.openide.filesystems.FileChangeListener;
import org.openide.filesystems.FileEvent;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileRenameEvent;
import org.openide.filesystems.FileUtil;

/**
 * ??TODO: do the file listnere to listen to jars changes and new/chnaged jars in Fantom lib folder. (and jdk ?? -> no, tsratup only)
 *
 * Index java jars - used through FanIndexer
 * @author tcolar
 */
public class FanJarsIndexer implements FileChangeListener
{

	public static final String UNRESOLVED_TYPE = "!!UNRESOLVED!!";
	private final static Pattern CLOSURECLASS = Pattern.compile(".*?\\$\\d+\\z");
	static JOTLoggerLocation log = new JOTLoggerLocation(FanIndexer.class);
	public static volatile boolean shutdown = false;
	Hashtable<String, Long> toBeIndexed = new Hashtable<String, Long>();

	public FanJarsIndexer()
	{
		super();
		long then = new Date().getTime();
		indexJars(false);
		long now = new Date().getTime();
		log.info("Fantom Jars Parsing completed in " + (now - then) + " ms.");
	}

	public void indexJars(boolean runInBackground)
	{
		FanJarsIndexerThread thread = new FanJarsIndexerThread();
		thread.start();
		if (!runInBackground)
		{
			thread.waitFor();
		}
	}

	private void indexJar(String j)
	{
		if (j.toLowerCase().endsWith(".jar"))
		{
			FanDocument doc = null;
			JarFile jar = new JarFile(j);

			Enumeration<JarEntry> jarEntries = jar.entries();
			while (jarEntries.hasMoreElements())
			{
				JarEntry entry = jarEntries.nextElement();
				String ename = entry.getName();
				if (ename.toLowerCase().endsWith(".class"))
				{
					String cname = ename.substring(0, ename.length() - 6).replaceAll(File.separator, ".");
					try
					{
						//System.out.println("cname: " + cname);
						// trying to findclass same class twice = no good !
						// also not bothering with sun internal classes
						if (!instance.classes.contains(cname)
							&& !cname.startsWith("sun.")
							&& !cname.startsWith("com.sun."))
						{
							//System.out.println("CP item: " + cname);
							String pack = instance.parsePackage(cname);
							indexPackages(pack);

							Class c = instance.findClass(cname);
							if (c != null)
							{
								if (c.isAnnotation())
								{
									instance.annotations.add(cname);
								} else if (c.isEnum())
								{
									instance.enums.add(cname);
								} else if (c.isInterface())
								{
									instance.interfaces.add(cname);
								} else
								{
									instance.classes.add(cname);
								}

								//System.out.println("Is interface");
							}
						}
					} catch (ClassNotFoundException ce)
					{
						FanUtilities.GENERIC_LOGGER.debug(ce.getMessage());
					}
				}

				/*
				try
				{
				ZipFile zpod = new ZipFile(pod);
				FPod fpod = new FPod(null, zpod, null);
				fpod.readFully();
				log.debug("Indexing pod: " + pod);
				// Create the document
				doc = FanDocument.findOrCreateOne(null, pod);
				if (doc.isNew())
				{
				doc.setPath(pod);
				doc.setTstamp(new Date().getTime());
				doc.setIsSource(false);
				doc.save();
				}
				Vector<FanType> types = FanType.findAllForDoc(null, doc.getId());

				for (FType type : fpod.types)
				{
				FTypeRef typeRef = type.pod.typeRef(type.self);
				String sig = typeRef.signature;
				int flags = type.flags;
				// Skipping "internal" classes - closures and the likes
				// synthetic means generated by compiler
				if (hasFlag(flags, FConst.Synthetic) || CLOSURECLASS.matcher(typeRef.typeName).matches())
				{
				continue;
				}
				log.debug("Indexing Pod Type: " + sig);

				JOTSQLCondition cond = new JOTSQLCondition("qualifiedName", JOTSQLCondition.IS_EQUAL, sig);
				FanType dbType = (FanType) JOTQueryBuilder.selectQuery(null, FanType.class).where(cond).findOrCreateOne();
				if (!dbType.isNew())
				{
				for (int i = 0; i != types.size(); i++)
				{
				FanType t = types.get(i);
				if (t.getId() == dbType.getId())
				{
				types.remove(i);
				break;
				}
				}
				}
				dbType.setDocumentId(doc.getId());
				dbType.setKind(getKind(type));
				dbType.setIsAbstract(hasFlag(flags, FConst.Abstract));
				dbType.setIsConst(hasFlag(flags, FConst.Const));
				dbType.setIsFinal(hasFlag(flags, FConst.Final));
				dbType.setQualifiedName(sig);
				dbType.setSimpleName(typeRef.typeName);
				dbType.setPod(typeRef.podName);
				dbType.setProtection(getProtection(type.flags));
				dbType.setIsFromSource(false);

				dbType.save();
				// Slots
				// Try to reuse existing db entries.
				Vector<FanSlot> currentSlots = FanSlot.findAllForType(dbType.getId());
				Vector<FSlot> slots = new Vector();
				slots.addAll(Arrays.asList(type.fields));
				slots.addAll(Arrays.asList(type.methods));
				for (FSlot slot : slots)
				{
				// determine kind of slot
				FanModelConstants.SlotKind kind = FanModelConstants.SlotKind.FIELD;
				FTypeRef retType = null;
				if (slot instanceof FField)
				{
				kind = FanModelConstants.SlotKind.FIELD;
				retType = type.pod.typeRef(((FField) slot).type);
				} else if (slot instanceof FMethod)
				{
				retType = type.pod.typeRef(((FMethod) slot).ret);
				if (hasFlag(slot.flags, FConst.Ctor))
				{
				kind = FanModelConstants.SlotKind.CTOR;
				} else
				{
				kind = FanModelConstants.SlotKind.METHOD;
				}
				} else
				{
				throw new RuntimeException("Unexpected Slot kind: " + slot.getClass().getName());
				}

				JOTSQLCondition cond2 = new JOTSQLCondition("typeId", JOTSQLCondition.IS_EQUAL, dbType.getId());
				JOTSQLCondition cond3 = new JOTSQLCondition("name", JOTSQLCondition.IS_EQUAL, slot.name);
				FanSlot dbSlot = (FanSlot) JOTQueryBuilder.selectQuery(null, FanSlot.class).where(cond2).where(cond3).findOrCreateOne();
				if (!dbSlot.isNew())
				{
				for (int i = 0; i != currentSlots.size(); i++)
				{
				FanSlot s = currentSlots.get(i);
				if (s.getId() == dbSlot.getId())
				{
				currentSlots.remove(i);
				break;
				}
				}
				}
				dbSlot.setTypeId(dbType.getId());
				dbSlot.setSlotKind(kind.value());
				dbSlot.setReturnedType(retType.signature);
				dbSlot.setName(slot.name);
				dbSlot.setIsAbstract(hasFlag(slot.flags, FConst.Abstract));
				dbSlot.setIsNative(hasFlag(slot.flags, FConst.Native));
				dbSlot.setIsOverride(hasFlag(slot.flags, FConst.Override));
				dbSlot.setIsStatic(hasFlag(slot.flags, FConst.Static));
				dbSlot.setIsVirtual(hasFlag(slot.flags, FConst.Virtual));
				dbSlot.setIsConst(hasFlag(slot.flags, FConst.Const));
				dbSlot.setProtection(getProtection(slot.flags));
				dbSlot.setIsNullable(retType.isNullable());

				dbSlot.save();

				// deal with parameters of method/ctor
				if (slot instanceof FMethod)
				{

				FMethod method = (FMethod) slot;
				FMethodVar[] parameters = method.params();
				// Try to reuse existing db entries.
				Vector<FanMethodParam> currentParams = FanMethodParam.findAllForSlot(dbSlot.getId());
				for (FMethodVar param : parameters)
				{
				JOTSQLCondition cond4 = new JOTSQLCondition("slotId", JOTSQLCondition.IS_EQUAL, dbSlot.getId());
				FanMethodParam dbParam = (FanMethodParam) JOTQueryBuilder.selectQuery(null, FanMethodParam.class).where(cond4).findOrCreateOne();
				if (!dbParam.isNew())
				{
				for (int i = 0; i != currentParams.size(); i++)
				{
				FanMethodParam p = currentParams.get(i);
				if (p.getId() == dbParam.getId())
				{
				currentParams.remove(i);
				break;
				}
				}
				}
				FTypeRef tRef = type.pod.typeRef(param.type);
				dbParam.setSlotId(dbSlot.getId());
				dbParam.setName(param.name);
				dbParam.setQualifiedType(tRef.signature);
				dbParam.setIsNullable(tRef.isNullable());
				dbParam.setHasDefault(param.def != null);

				dbParam.save();

				} // end param loop
				// Whatever param wasn't removed from the vector is not needed anymore.
				for (FanMethodParam param : currentParams)
				{
				param.delete();
				}
				}
				} // end slot loop
				// Whatever slot wasn't removed from the vector is not needed anymore.
				for (FanSlot s : currentSlots)
				{
				s.delete();
				}

				}

				for (FanType t : types)
				{
				t.delete();
				}
				} catch (Exception e)
				{
				log.exception("Indexing failed for: " + pod, e);
				try
				{
				// remove broken enrty, will try again next time
				if (doc != null)
				{
				doc.delete();
				}
				} catch (Exception e2)
				{
				log.exception("Indexing 'rollback' failed for: " + pod, e);
				}
				}
				}*/
			}
		}
	}

	public static void shutdown()
	{
		shutdown = true;
	}

	//*********** File listeners ****************************
	public void fileFolderCreated(FileEvent fe)
	{
		// Listen for changes
		String path = fe.getFile().getPath();
		log.debug("Folder created: " + path);
		FileUtil.addFileChangeListener(this, FileUtil.toFile(fe.getFile()));
	}

	public void fileDataCreated(FileEvent fe)
	{
		String path = fe.getFile().getPath();
		log.debug("File created: " + path);
		indexJar(
			path);
	}

	public void fileChanged(FileEvent fe)
	{
		String path = fe.getFile().getPath();
		log.debug("File changed: " + path);
		indexJar(
			path);
	}

	public void fileDeleted(FileEvent fe)
	{
		String path = fe.getFile().getPath();
		log.debug("File deleted: " + path);
		FanDocument.deleteForPath(null, path);
	}

	public void fileRenamed(FileRenameEvent fre)
	{
		// TODO: not sure if that's good
		FileObject src = (FileObject) fre.getSource();
		log.debug("File renamed: " + src.getPath() + " -> " + fre.getFile().getPath());
		FanDocument.renameDoc(src.getPath(), fre.getFile().getPath());
	}

	public void fileAttributeChanged(FileAttributeEvent fae)
	{
		// don't care
	}

	/**
	 * Places we are going to look for jars at.
	 * @return
	 */
	public List<URL> getJarPaths()
	{
		ArrayList<URL> urls = new ArrayList<URL>();
		// adding Fan jars
		URL[] fanUrls = FanJavaClassLoader.getExtUrls();
		for (URL url : fanUrls)
		{
			urls.add(url);
		}
		// JVM cp
		String javaHome = JavaPlatform.getDefault().getSystemProperties().get("java.home");
		String lib = javaHome + File.separator + "lib" + File.separator;
		String[] cps = JavaPlatform.getDefault().getSystemProperties().get("sun.boot.class.path").split(File.pathSeparator);
		for (String cp : cps)
		{
			String f = new File(cp).getName();
			File file = new File(f);
			// skip those large resources jars to save time.
			if (f.equals("deploy.jar") || f.equals("charsets.jar") || f.equals("javaws.jar"))
			{
				continue;
			} //System.out.println("jbcp: " + cp);
			try
			{
				urls.add(new URL("file://" + cp));
			} catch (IOException e)
			{
				e.printStackTrace();
			}
		}
		// use lib/rt.jar as the backup
		if (cps.length == 0)
		{
			String cp = lib + "rt.jar";
			FanUtilities.GENERIC_LOGGER.debug("jrtcp: " + cp);
			try
			{
				urls.add(new URL("file://" + cp));
			} catch (IOException e)
			{
				e.printStackTrace();
			}
		}
		// jvm lib/ext/*
		File[] ext = new File(lib + "ext").listFiles();
		for (File jar : ext)
		{
			//System.out.println("jecp: " + jar.getAbsolutePath());
			try
			{
				urls.add(new URL("file://" + jar.getAbsolutePath()));
			} catch (IOException e)
			{
				e.printStackTrace();
			}
		}
		return urls;
	}

	/*********************************************************************
	 *  Indexer Thread class
	 */
	class FanJarsIndexerThread extends Thread implements Runnable
	{

		volatile boolean done = false;

		@Override
		public void run()
		{
			done = false;
			try
			{
				for (URL url : getJarPaths())
				{
					if (shutdown)
					{
						break;
					}
					String file = url.getFile();
					if (file.toLowerCase().endsWith(".jar"))
					{
						// boot clasppath lists sme jars that do not necerally exists (optional)
						File jar = new File(file);
						if (jar.exists())
						{
							FanUtilities.GENERIC_LOGGER.debug("Indexing jar:  " + jar);
							// listen to changes
							FileUtil.addFileChangeListener(FanJarsIndexer.this, jar);
							// index the pods if not up to date
							String path = jar.getAbsolutePath();
							if (FanIndexer.checkIfNeedsReindexing(path, jar.lastModified()))
							{
								indexJar(path);
							}
						}
					}
				}
			} catch (Throwable t)
			{
				log.exception("Pod indexing thread error", t);
			}

			done = true;
		}

		private void waitFor()
		{
			while (!done)
			{
				try
				{
					sleep(50);
				} catch (Exception e)
				{
				}
			}
		}
	}
}
