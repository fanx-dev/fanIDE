/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.colar.netbeans.fan;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Vector;
import javax.swing.text.Document;
import net.colar.netbeans.fan.indexer.model.FanSlot;
import net.colar.netbeans.fan.scope.FanAstScopeVar;
import net.colar.netbeans.fan.parboiled.FanLexAstUtils;
import net.colar.netbeans.fan.indexer.model.FanType;
import net.colar.netbeans.fan.parboiled.AstKind;
import net.colar.netbeans.fan.parboiled.AstNode;
import net.colar.netbeans.fan.parboiled.FantomParser;
import net.colar.netbeans.fan.parboiled.FantomParserTokens.TokenName;
import net.colar.netbeans.fan.parboiled.pred.NodeKindPredicate;
import net.colar.netbeans.fan.scope.FanAstScopeVarBase;
import net.colar.netbeans.fan.scope.FanAstScopeVarBase.VarKind;
import net.colar.netbeans.fan.scope.FanLocalScopeVar;
import net.colar.netbeans.fan.scope.FanTypeScopeVar;
import net.colar.netbeans.fan.types.FanResolvedListType;
import net.colar.netbeans.fan.types.FanResolvedMapType;
import net.colar.netbeans.fan.types.FanResolvedNullType;
import net.colar.netbeans.fan.types.FanResolvedType;
import net.colar.netbeans.fan.types.FanUnknownType;
import org.netbeans.modules.csl.api.Error;
import org.netbeans.modules.csl.api.OffsetRange;
import org.netbeans.modules.csl.api.Severity;
import org.netbeans.modules.csl.spi.DefaultError;
import org.netbeans.modules.csl.spi.ParserResult;
import org.netbeans.modules.parsing.api.Snapshot;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.parboiled.Node;
import org.parboiled.Parboiled;
import org.parboiled.RecoveringParseRunner;
import org.parboiled.errors.ErrorUtils;
import org.parboiled.errors.ParseError;
import org.parboiled.support.ParseTreeUtils;
import org.parboiled.support.ParsingResult;

/**
 * Parse a fan file and holds the results
 * parse() parses the file
 * parseScope() adds to the tree scope vraiables etc...
 * @author  tcolar
 */
public class FanParserTask extends ParserResult
{

	List<Error> errors = new Vector<Error>(); // -> use parsingResult.errors ?
	// full path of the source file
	private final FileObject sourceFile;
	// simple name of the source file
	private final String sourceName;
	// pod name
	private final String pod;
	// once parse() is called, will contain the parboiled parsing result
	private ParsingResult<AstNode> parsingResult;
	private AstNode astRoot;

	public FanParserTask(Snapshot snapshot)
	{
		super(snapshot);
		sourceName = snapshot.getSource().getFileObject().getName();
		sourceFile = FileUtil.toFileObject(new File(snapshot.getSource().getFileObject().getPath()));
		pod = FanUtilities.getPodForPath(sourceFile.getPath());
	}

	@Override
	public List<? extends Error> getDiagnostics()
	{
		return errors;
	}

	@Override
	protected void invalidate()
	{
		// what should this do ?
	}

	/**
	 * Return AST tree generated by this parsing
	 * @return
	 */
	public Node getParseNodeTree()
	{
		if (parsingResult != null)
		{
			return parsingResult.parseTreeRoot;
		}
		return null;
	}

	public AstNode getAstTree()
	{
		Node<AstNode> nd = getParseNodeTree();
		return nd == null ? null : nd.getValue();
	}

	/**
	 * Dump AST tree 
	 */
	public void dumpTree()
	{
		FanUtilities.GENERIC_LOGGER.trace("-------------------Start AST Tree dump-----------------------");
		ParseTreeUtils.printNodeTree(parsingResult);
		FanUtilities.GENERIC_LOGGER.trace("-------------------End AST Tree dump-----------------------");
	}

	/**
	 * Shotcut method for getSnapshot().getSource().getDocument(true);
	 * @return
	 */
	public Document getDocument()
	{
		return getSnapshot().getSource().getDocument(true);
	}

	public void addError(String title, Throwable t)
	{
		// "High level error"
		Error error = DefaultError.createDefaultError(title, title, title, null, 0, 0, true, Severity.ERROR);
		errors.add(error);
	}

	/**
	 * The root scope
	 * @return
	 */
	public AstNode getRootScope()
	{
		return astRoot;
	}

	public FileObject getSourceFile()
	{
		return sourceFile;
	}

	/**
	 * Add an error (not the parser errors, but others like semantic etc..)
	 * @param info
	 * @param node
	 */
	public void addError(String info, AstNode node)
	{
		if (node == null)
		{
			return;
		}
		String key = "FanParserTask";
		OffsetRange range = FanLexAstUtils.getNodeRange(node);
		int start = range.getStart();
		int end = range.getEnd();
		//System.out.println("Start: "+start+"End:"+end);
		Error error = DefaultError.createDefaultError(key, info, "Syntax Error", sourceFile, start, end, true, Severity.ERROR);
		errors.add(error);
	}

	/**
	 * Parse the file (using parboiled FantomParser)
	 */
	public void parse()
	{
		long start = new Date().getTime();
		FanUtilities.GENERIC_LOGGER.debug("Starting parsing of: " + sourceName);

		FantomParser parser = Parboiled.createParser(FantomParser.class, this);

		try
		{
			parsingResult = RecoveringParseRunner.run(parser.compilationUnit(), getSnapshot().getText().toString());
			// Copy parboiled parse error into a CSL errrors
			for (ParseError err : parsingResult.parseErrors)
			{
				// key, displayName, description, file, start, end, lineError?, severity
				String msg = ErrorUtils.printParseError(err, parsingResult.inputBuffer);
				Error error = DefaultError.createDefaultError(msg, msg, msg,
						sourceFile, err.getErrorLocation().getIndex(), err.getErrorLocation().getIndex() + err.getErrorCharCount(),
						false, Severity.ERROR);
				errors.add(error);
			}
			if (parsingResult.parseTreeRoot != null)
			{
				astRoot = parsingResult.parseTreeRoot.getValue();
				// Removed orphaned(backtracked) AST nodes.
				prune(astRoot);
			}
		} catch (Exception e)
		{
			addError("Parser error", e);
			e.printStackTrace();
		}

		FanUtilities.GENERIC_LOGGER.info("Parsing completed in " + (new Date().getTime() - start) + " for : " + sourceName);
	}

	/**
	 * Call after parsing to add scope variables / type resolution to the AST tree
	 */
	public void parseScope()
	{
		long start = new Date().getTime();
		FanUtilities.GENERIC_LOGGER.debug("Starting parsing scope of: " + sourceName);
		if (astRoot == null)
		{
			return;
		}
		// First run : lookup using statements
		for (AstNode node : astRoot.getChildren())
		{
			switch (node.getKind())
			{
				case AST_INC_USING:
					addError("Incomplete import statement", node);
					break;

				case AST_USING:
					addUsing(node);
					break;

			}
		}

		// Second pass, lookup types and slots
		for (AstNode node : astRoot.getChildren())
		{
			switch (node.getKind())
			{
				case AST_TYPE_DEF:
					String name = FanLexAstUtils.getFirstChildText(node, new NodeKindPredicate(AstKind.AST_ID));
					FanTypeScopeVar var = new FanTypeScopeVar(node, name);
					AstNode scopeNode = FanLexAstUtils.getScopeNode(node.getRoot());
					// We parse the type base first and add it to scope right away
					// So that parseSlots() can later resolve this & super.
					var.parse();
					if (scopeNode.getAllScopeVars().containsKey(name))
					{
						addError("Duplicated type name", node);
					} else
					{
						scopeNode.getLocalScopeVars().put(name, var);
					}
					// Parse the slots
					var.parseSlots();
					break;
			}
		}
		// Now do all the local scopes / variables
		for (AstNode node : astRoot.getChildren())
		{
			if (node.getKind() == AstKind.AST_TYPE_DEF)
			{
				for (FanAstScopeVarBase var : node.getLocalScopeVars().values())
				{
					// should be slots
					AstNode bkNode = var.getNode();
					AstNode blockNode = FanLexAstUtils.getFirstChild(bkNode, new NodeKindPredicate(AstKind.AST_BLOCK));
					if (blockNode != null)
					{
						parseVars(blockNode, null);
					}
				}
			}
		}

		//FanLexAstUtils.dumpTree(astRoot, 0);
		FanUtilities.GENERIC_LOGGER.info("Parsing of scope completed in " + (new Date().getTime() - start) + " for : " + sourceName);
	}
	//TODO: don't show the whole stack of errors, but just the base.
	// esp. for expressions, calls etc...

	private void parseVars(AstNode node, FanResolvedType type)
	{
		if (node == null)
		{
			return;
		}
		// If base type is unknown ... so are child
		if (type instanceof FanUnknownType)
		{
			node.setType(type);
			// Note: all children(if any) will be "unknown" as well.
			for (AstNode nd : node.getChildren())
			{
				parseVars(nd, type);
			}
			return;
		}

		String text = node.getNodeText(true);
		switch (node.getKind())
		{
			case AST_CLOSURE:
				type = doClosure(node, type);
				break;
			case AST_EXPR_INDEX:
				type = doIndexExpr(node, type);
				break;
			case AST_LIST:
				// Index expressions, sometimes get parsed as Lists because the parser doesn't know a Type vs a variable
				// so str[0] gets parsed as a list (like Str[0] would be) rather than an index expr
				// so dolist takes care of that issue.
				type = doList(node, type);
				break;
			case AST_MAP:
				type = doMap(node, type);
				break;
			case AST_EXPR:
			case AST_EXPR_ASSIGN: // with the assignment we need reset type to null (start a new expression)
			case AST_EXPR_MULT:
			case AST_EXPR_ADD:
				type = doExpr(node, type);
				break;
			case AST_EXPR_CALL:
				type = doCall(node, type);
				break;
			case AST_ARG:
				// arg contains one expression - parse it to check for errors
				AstNode argExprNode = node.getChildren().get(0);
				parseVars(argExprNode, null);
				type = argExprNode.getType();
				break;
			case AST_CHILD: // a wrapper node (takes type from wrapped node)
				parseChildren(node);
				if (node.getChildren().size() != 1)
				{
					throw new RuntimeException("AST_CHILD should have only one child node");
				}
				type = node.getChildren().get(0).getType();
				break;
			case AST_EXR_CAST:
				parseChildren(node);
				AstNode castTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
				type = castTypeNode.getType();
				//TODO: check if cast is valid
				break;
			case AST_EXPR_TYPE_CHECK:
				type = doTypeCheckExpr(node, type);
				break;
			case AST_EXPR_RANGE:
				// if only one child, then it's really not a rangeExpr, but an addExpr
				if (node.getChildren().size() == 1)
				{
					parseVars(node.getChildren().get(0), type);
					type = node.getChildren().get(0).getType();
				} else
				{
					type = doRangeExpr(node, type);
				}
				break;
			case AST_IT_BLOCK:
				type = doItBlock(node, type);
				break;
			case AST_CATCH_BLOCK:
				type = doCatchBlock(node, type);
				break;
			case AST_EXPR_LIT_BASE:
				Node<AstNode> parseNode = node.getParseNode().getChildren().get(0); // firstOf
				type = resolveLitteral(node, parseNode);
				break;
			case AST_ID:
				type = FanResolvedType.makeFromLocalID(node, text);
				break;
			case AST_TYPE:
				type = FanResolvedType.fromTypeSig(node, text);
				break;
			case AST_LOCAL_DEF: // special case, since it introduces scope vars
				type = doLocalDef(node, type);
				break;
			default:
				// recurse into children
				parseChildren(node);
		}

		node.setType(type);
		if (type != null && !type.isResolved())
		{
			node.getRoot().getParserTask().addError("Could not resolve item -> " + text, node);
			FanUtilities.GENERIC_LOGGER.info(">Unresolved node");
			FanLexAstUtils.dumpTree(node, 0);
			//FanLexAstUtils.dumpTree(astRoot, 0);
			FanUtilities.GENERIC_LOGGER.info("<Unresolved node");
		}
	}

	private void parseChildren(AstNode node)
	{
		for (AstNode child : node.getChildren())
		{
			parseVars(child, null);
		}
	}

	public FanResolvedType resolveLitteral(AstNode astNode, Node<AstNode> parseNode)
	{
		FanResolvedType type = FanResolvedType.makeUnresolved(astNode);
		String lbl = parseNode.getLabel();
		String txt = astNode.getNodeText(true);
		if (lbl.equalsIgnoreCase(TokenName.ID.name()))
		{
			type = FanResolvedType.makeFromLocalID(astNode, txt);
		} else if (lbl.equalsIgnoreCase(TokenName.CHAR_.name()))
		{
			type = FanResolvedType.fromTypeSig(astNode, "sys::Int");
		} else if (lbl.equalsIgnoreCase(TokenName.NUMBER.name()))
		{
			char lastChar = txt.charAt(txt.length() - 1);
			if (lastChar == 'f' || lastChar == 'F')
			{
				type = FanResolvedType.fromTypeSig(astNode, "sys::Float");
			} else if (lastChar == 'd' || lastChar == 'D')
			{
				type = FanResolvedType.fromTypeSig(astNode, "sys::Decimal");
			} else if (Character.isLetter(lastChar) && lastChar != '_')
			{
				type = FanResolvedType.fromTypeSig(astNode, "sys::Duration");
			} else if (txt.indexOf(".") != -1)
			{
				type = FanResolvedType.fromTypeSig(astNode, "sys::Float");
			} else
			{
				type = FanResolvedType.fromTypeSig(astNode, "sys::Int"); // Default
			}
		} else if (lbl.equalsIgnoreCase(TokenName.STRS.name()))
		{
			type = FanResolvedType.fromTypeSig(astNode, "sys::Str");
		} else if (lbl.equalsIgnoreCase(TokenName.URI.name()))
		{
			type = FanResolvedType.fromTypeSig(astNode, "sys::Uri");
		} else if (lbl.equals("true") || lbl.equals("false"))
		{
			type = FanResolvedType.fromTypeSig(astNode, "sys::Bool");
		} else if (lbl.equals("null"))
		{
			type = new FanResolvedNullType(astNode);
		} else if (lbl.equals("it"))
		{
			FanAstScopeVarBase var = astNode.getAllScopeVars().get("it");
			if (var != null)
			{
				type = var.getType();
			}
			type.setStaticContext(false);
		} else if (lbl.equals("this"))
		{
			type = FanResolvedType.resolveThisType(astNode);
			type.setStaticContext(false);
		} else if (lbl.equals("super"))
		{
			type = FanResolvedType.resolveSuper(astNode);
			type.setStaticContext(false);
		}
		return type;
	}

	private void addUsing(AstNode usingNode)
	{
		String type = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_ID));
		String as = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_USING_AS));
		String ffi = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_USING_FFI));

		String name = as != null ? as : type;
		if (name.indexOf("::") > -1)
		{
			name = name.substring(name.indexOf("::") + 2);
		}

		if (ffi != null && ffi.toLowerCase().equals("java"))
		{
			if (type.indexOf("::") != -1)
			{
				// Individual Item
				String qname = type.replaceAll("::", "\\.");

				if (FanType.findByQualifiedName(qname) == null)
				{
					addError("Unresolved Java Item: " + qname, usingNode);
				} else
				{
					addUsing(name, qname, usingNode);
				}
			} else
			{
				// whole package
				if (!FanType.hasPod(name))
				{
					addError("Unresolved Java package: " + name, usingNode);
				} else
				{
					Vector<FanType> items = FanType.findPodTypes(name, "");
					for (FanType t : items)
					{
						addUsing(t.getSimpleName(), t.getQualifiedName(), usingNode);
					}
				}
			}
		} else
		{
			if (type.indexOf("::") > 0)
			{
				// Adding a specific type
				String[] data = type.split("::");
				if (!FanType.hasPod(data[0]))
				{
					addError("Unresolved Pod: " + data[0], usingNode);
				} else if (FanType.findByQualifiedName(type) == null)
				{
					addError("Unresolved Type: " + type, usingNode);
				}

				//Type t = FanPodIndexer.getInstance().getPodType(data[0], data[1]);
				addUsing(name, type, usingNode);
			} else
			{
				// Adding all the types of a Pod
				if (name.equalsIgnoreCase("sys")) // sys is always avail.
				{
					return;
				}
				if (!FanType.hasPod(name))
				{
					addError("Unresolved Pod: " + name, usingNode);
				} else
				{
					Vector<FanType> items = FanType.findPodTypes(name, "");
					for (FanType t : items)
					{
						addUsing(t.getSimpleName(), t.getQualifiedName(), usingNode);
					}
				}
			}
		}
	}

	private void addUsing(String name, String qType, AstNode node)
	{
		AstNode scopeNode = FanLexAstUtils.getScopeNode(node);
		if (scopeNode == null)
		{
			return;
		}
		if (scopeNode.getLocalScopeVars().containsKey(name))
		{
			// This is 'legal' ... maybe show a warning later ?
			//addError("Duplicated using: " + qType + " / " + scopeNode.getLocalScopeVars().get(name), node);
			System.out.println("Already have a using called: " + qType + " (" + scopeNode.getLocalScopeVars().get(name) + ")");
			// Note: only keeping the 'last' definition (ie: override)
		}
		FanResolvedType rType = FanResolvedType.makeFromDbType(node, qType);
		rType.setStaticContext(true);
		scopeNode.addScopeVar(name, FanAstScopeVar.VarKind.IMPORT, rType, true);
	}

	public ParsingResult<AstNode> getParsingResult()
	{
		return parsingResult;
	}

	public String getPod()
	{
		return pod;
	}

	/**
	 * TODO: this whole prunning stuff is a bit ugly
	 * Should try to buod the AST properly using technizues here:
	 * http://parboiled.hostingdelivered.com/viewtopic.php?f=3&t=9
	 *
	 * During ParseNode construction, some astNodes that migth have been constructed from
	 * some parseNode that where then "backtracked" (not the whoel sequence matched)
	 * This looks for and remove those unwanted nodes.
	 * @param node
	 */
	private void prune(AstNode node)
	{
		Node<AstNode> rtNode = astRoot.getParseNode();
		String rootLabel = "n/a";
		while (rtNode != null)
		{
			rootLabel = rtNode.getLabel();
			rtNode = rtNode.getParent();
		}
		List<AstNode> children = node.getChildren();
		List<AstNode> toBepruned = new ArrayList<AstNode>();
		for (AstNode child : children)
		{
			Node<AstNode> parseNode = child.getParseNode();
			// If the node is orphaned (no link back to the root), that means it was backtracked out of.
			String label = "N/A";
			while (parseNode != null)
			{
				label = parseNode.getLabel();
				parseNode = parseNode.getParent();
			}
			if (!rootLabel.equals(label))
			{
				toBepruned.add(child);
			} else
			{
				// recurse into children
				prune(child);
			}
		}
		// Drop the orphaned nodes
		for (AstNode nd : toBepruned)
		{
			children.remove(nd);
		}
	}

	private FanResolvedType doExpr(AstNode node, FanResolvedType type)
	{
		// TODO: validate assignment type is compatible.
		boolean first = true;
		type = null;
		for (AstNode child : node.getChildren())
		{
			parseVars(child, type);
			// Those kinds take the right hand side type
			// It block chnages the type because it makes it NOT staticContext
			if (first || child.getKind() == AstKind.AST_EXPR_CALL || child.getKind() == AstKind.AST_EXPR_TYPE_CHECK
					|| child.getKind() == AstKind.AST_EXPR_RANGE || child.getKind() == AstKind.AST_EXPR_ASSIGN || child.getKind() == AstKind.AST_EXPR_LIT_BASE
					|| child.getKind() == AstKind.AST_IT_BLOCK || child.getKind() == AstKind.AST_EXPR_ADD)
			{
				type = child.getType();
			}
			first = false;
		}
		return type;
	}

	private FanResolvedType doCall(AstNode node, FanResolvedType type)
	{
		AstNode callChild = node.getChildren().get(0);
		String slotName = callChild.getNodeText(true);
		//if a direct call like doThis(), then use this type as base
		if (type == null)
		{
			type = FanResolvedType.makeFromLocalID(callChild, slotName);
		} else
		// otherwise a slot of the base type like var.toStr()
		{
			//if(! (type instanceof FanUnknownType))
			type = FanResolvedType.resolveSlotType(type, slotName);
		}

		List<AstNode> args = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_ARG));
		for (AstNode arg : args)
		{
			parseVars(arg, null);
		}
		//TODO: Check that param types matches slot declaration
		AstNode closure = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_CLOSURE));
		if (closure != null)
		{
			parseVars(closure, null);
		}
		return type;
	}

	private FanResolvedType doClosure(AstNode node, FanResolvedType type)
	{
		AstNode closureBlock = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_BLOCK));
		FanResolvedType retType = FanResolvedType.makeFromDbType(node, "sys::Void");
		for (AstNode child : node.getChildren())
		{
			if (child.getKind() == AstKind.AST_FORMAL)
			{
				AstNode formalName = FanLexAstUtils.getFirstChild(child, new NodeKindPredicate(AstKind.AST_ID));
				AstNode formalTypeAndId = FanLexAstUtils.getFirstChild(child, new NodeKindPredicate(AstKind.AST_TYPE_AND_ID));
				// TODO: try to deal with inference ??
						/*
				 * Closures like on each are inferred by the function parameter on the method being called.

				For example each on a Field[] will have a parametered signature of each(|Field f| func) which is how f gets typed a Field.

				The place it happens in my code is CallResolver.inferClosureTypeFromCall

				Take a look at thru that code and see if it makes it clearer.  Remember it works with any method that takes a function.

				For example if the method is:

				foo(|Str, Int, Float| f)

				Then

				foo |a, b, c| {}  =>  foo |Str a, Int b, Float c| {}
				 *
				 * fansh> t := List#.parameterize(["V":Str#])
				sys::Str[]
				fansh> t.method("each").signature
				sys::Void each(|sys::Str,sys::Int->sys::Void| c)
				 */
				//FanResolvedType fType = FanResolvedType.makeFromDbType(child, "sys::Obj");
				FanResolvedType fType = new FanUnknownType(node, node.getNodeText(true)); //TODO: resolve formal type
				if (formalTypeAndId != null)
				{ // if inferred this is null
					formalName = FanLexAstUtils.getFirstChild(formalTypeAndId, new NodeKindPredicate(AstKind.AST_ID));
					AstNode formalType = FanLexAstUtils.getFirstChild(formalTypeAndId, new NodeKindPredicate(AstKind.AST_TYPE));
					parseVars(formalType, null);
					fType = formalType.getType();
				}
				// add the formals vars to the closure block scope
				closureBlock.addScopeVar(formalName.getNodeText(true), VarKind.LOCAL, fType, true);
			}
			if (child.getKind() == AstKind.AST_TYPE)
			{
				// save the returned type
				parseVars(child, type);
				retType = child.getType();
			}
			if (child.getKind() == AstKind.AST_BLOCK)
			{
				// parse the block content
				parseVars(child, type);
			}
		}
		type = retType;
		return type;
	}

	/**
	 *	Index expressions, sometimes get parsed as Lists because the parser doesn't know a Type vs a variable
	 *	so str[0] gets parsed as a list (like Str[0] would be) rather than an index expr
	 *  So we deal with this here.
	 * @param node
	 * @param type
	 * @return
	 */
	private FanResolvedType doList(AstNode node, FanResolvedType type)
	{
		AstNode listTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
		List<AstNode> listExprNodes = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_EXPR));
		List<FanResolvedType> listTypes = new ArrayList();
		if (listTypeNode != null)
		{   // if it's a typed list, use that as the type
			parseVars(listTypeNode, null);
			if ( ! listTypeNode.getType().isStaticContext())
			{
				// It's NOT a List at all after all, but an index expression (called on a var, not a Static type)!
				return doIndexExpr(node, type);
			}

			type = new FanResolvedListType(node,
					listTypeNode.getType());
		}

		for (AstNode listExpr : listExprNodes)
		{
			parseVars(listExpr, null);
			listTypes.add(listExpr.getType());
		}
		if (listTypeNode == null)
		{   // try to infer it from the expr Nodes
			type = new FanResolvedListType(node,
					FanResolvedType.makeFromItemList(node, listTypes));
		}
		return type;
	}

	private FanResolvedType doMap(AstNode node, FanResolvedType type)
	{
		AstNode mapTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
		List<AstNode> mapPairNodes = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_MAP_PAIR));
		List<FanResolvedType> mapKeyTypes = new ArrayList();
		List<FanResolvedType> mapValTypes = new ArrayList();
		for (AstNode mapPair : mapPairNodes)
		{
			AstNode mapKey = mapPair.getChildren().get(0);
			AstNode mapVal = mapPair.getChildren().get(1);
			parseVars(mapKey, null);
			parseVars(mapVal, null);
			mapKeyTypes.add(mapKey.getType());
			mapValTypes.add(mapVal.getType());
		}
		if (mapTypeNode != null)
		{   // if it's a typed list, use that as the type
			parseVars(mapTypeNode, null);
			type = mapTypeNode.getType();
		} else
		{ // otherwise try to infer it from the expr Nodes
			type = new FanResolvedMapType(node,
					FanResolvedType.makeFromItemList(node, mapKeyTypes),
					FanResolvedType.makeFromItemList(node, mapValTypes));
		}
		return type;
	}

	private FanResolvedType doIndexExpr(AstNode node, FanResolvedType type)
	{
		parseChildren(node);
		FanResolvedType slotType = FanResolvedType.resolveSlotType(type, "get");
		if (type instanceof FanResolvedListType)
		{
			type = ((FanResolvedListType) type).getItemType();
		} else if (type instanceof FanResolvedMapType)
		{
			type = ((FanResolvedMapType) type).getValType();
		} //Can also use index expression on any type with a get method
		else if (slotType != null && slotType.isResolved())
		{
			type = slotType;
		} else
		{
			type = null;
			node.getRoot().getParserTask().addError("Index expression only valid on lists, maps or types with get method-> " + node.getNodeText(true), node);
		}
		// TODO: check if list/map index key type is valid ?
		return type;
	}

	private FanResolvedType doTypeCheckExpr(AstNode node, FanResolvedType type)
	{
		String text = node.getNodeText(true);
		parseChildren(node);
		AstNode checkType = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
		if (text.startsWith("as")) // (cast)
		{
			type = checkType.getType();
		} else if (text.startsWith("is")) // is or isnot	-> boolean
		{
			type = FanResolvedType.makeFromDbType(node, "sys::Bool");
		} else
		{
			type = null; // shouldn't happen
		}
		return type;
	}

	private FanResolvedType doItBlock(AstNode node, FanResolvedType type)
	{
		// introduce itblock scope variables
		if (type != null && type.getDbType() != null)
		{
			type.setStaticContext(false);
			List<FanSlot> itSlots = FanSlot.getAllSlotsForType(type.getDbType().getQualifiedName(), false);
			for (FanSlot itSlot : itSlots)
			{
				FanAstScopeVarBase newVar = new FanLocalScopeVar(node, itSlot, itSlot.getName());
				node.addScopeVar(newVar, true);
			}
			// add "it" to scope
			FanAstScopeVarBase itVar = new FanLocalScopeVar(node, VarKind.IMPLIED, "it", type);
			node.addScopeVar(itVar, true);
		}
		parseChildren(node);
		return type;
	}

	private FanResolvedType doLocalDef(AstNode node, FanResolvedType type)
	{
		AstNode typeAndIdNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE_AND_ID));
		AstNode idNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_ID));
		AstNode exprNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_EXPR));
		if (typeAndIdNode != null)
		{
			idNode = FanLexAstUtils.getFirstChild(typeAndIdNode, new NodeKindPredicate(AstKind.AST_ID));
			AstNode typeNode = FanLexAstUtils.getFirstChild(typeAndIdNode, new NodeKindPredicate(AstKind.AST_TYPE));
			parseVars(typeNode, null);
			type = typeNode.getType();
		}

		String name = idNode.getNodeText(true);

		if (exprNode != null)
		{
			parseVars(exprNode, null);
			if (type == null) // Prefer the type in TypeNode if specified
			{
				type = exprNode.getType();
				//TODO: check types are compatible
			}
		}
		if (type != null)
		{
			type.setStaticContext(false);
		}
		node.addScopeVar(new FanLocalScopeVar(node, VarKind.LOCAL, name, type), false);
		return type;
	}

	private FanResolvedType doRangeExpr(AstNode node, FanResolvedType type)
	{
		parseChildren(node);
		if (type == null)
		{
			// a range like (0..5)
			type = new FanResolvedListType(node, node.getChildren().get(0).getType());
		} else if (type instanceof FanResolvedListType)
		{
			// a range like list[0..5]
			type = ((FanResolvedListType) type).getItemType();
		} else if (type instanceof FanResolvedMapType)
		{
			// a range like map[0..5]
			type = ((FanResolvedMapType) type).getValType();
		} else
		{
			// a range like "mystring"[0..5]
			type = FanResolvedType.resolveSlotType(type, "get");
		}
		return type;
	}

	private FanResolvedType doCatchBlock(AstNode node, FanResolvedType type)
	{
		AstNode typeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
		AstNode idNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_ID));
		AstNode blockNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_BLOCK));
		if (typeNode != null && idNode != null && blockNode!=null)
		{
			parseVars(typeNode, null);
			// add exception variable to block scope
			FanAstScopeVarBase itVar = new FanLocalScopeVar(node, VarKind.LOCAL, idNode.getNodeText(true), typeNode.getType());
			blockNode.addScopeVar(itVar, true);
			// Now parse the block
			parseVars(blockNode, null);
		}
		return type;
	}

}


