/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.colar.netbeans.fan.parser;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.*;
import javax.swing.text.Document;
import net.colar.netbeans.fan.utils.FanUtilities;
import net.colar.netbeans.fan.indexer.FanIndexerFactory;
import net.colar.netbeans.fan.namespace.FanMethodParam;
import net.colar.netbeans.fan.namespace.FanSlot;
import net.colar.netbeans.fan.parser.parboiled.FanLexAstUtils;
import net.colar.netbeans.fan.namespace.FanType;
import net.colar.netbeans.fan.namespace.Namespace;
import net.colar.netbeans.fan.parser.parboiled.AstKind;
import net.colar.netbeans.fan.parser.parboiled.AstNode;
import net.colar.netbeans.fan.parser.parboiled.CancellableRecoveringParserRunner;
import net.colar.netbeans.fan.parser.parboiled.FantomParser;
import net.colar.netbeans.fan.parser.parboiled.FantomLexerTokens.TokenName;
import net.colar.netbeans.fan.parser.parboiled.FantomParserAstActions;
import net.colar.netbeans.fan.parser.parboiled.ParserCancelledError;
import net.colar.netbeans.fan.parser.parboiled.pred.NodeKindPredicate;
import net.colar.netbeans.fan.project.FanBuildFileHelper;
import net.colar.netbeans.fan.scope.FanAstScopeVarBase;
import net.colar.netbeans.fan.scope.FanAstScopeVarBase.VarKind;
import net.colar.netbeans.fan.scope.FanLocalScopeVar;
import net.colar.netbeans.fan.scope.FanMethodScopeVar;
import net.colar.netbeans.fan.scope.FanTypeScopeVar;
import net.colar.netbeans.fan.types.FanResolvedFuncType;
import net.colar.netbeans.fan.types.FanResolvedListType;
import net.colar.netbeans.fan.types.FanResolvedMapType;
import net.colar.netbeans.fan.types.FanResolvedNullType;
import net.colar.netbeans.fan.types.FanResolvedType;
import net.colar.netbeans.fan.types.FanUnknownType;
import net.colar.netbeans.fan.utils.GenericPair;
import org.netbeans.modules.csl.api.Error;
import org.netbeans.modules.csl.api.OffsetRange;
import org.netbeans.modules.csl.api.Severity;
import org.netbeans.modules.csl.spi.DefaultError;
import org.netbeans.modules.csl.spi.ParserResult;
import org.netbeans.modules.parsing.api.Snapshot;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.parboiled.Context;
import org.parboiled.Node;
import org.parboiled.Parboiled;
import org.parboiled.errors.ErrorUtils;
import org.parboiled.errors.ParseError;
import org.parboiled.support.ParseTreeUtils;
import org.parboiled.support.ParsingResult;

/**
 * Parse a fan file and holds the results parse() parses the file parseScope()
 * adds to the tree scope variables etc...
 *
 * @author tcolar
 */
public class FanParserTask extends ParserResult {

    boolean invalidated = false;
    public boolean dumpTree = false; // debug
    List<Error> errors = new ArrayList<Error>(); // -> use parsingResult.errors ?

    // full path of the source file
    private final FileObject sourceFile;
    // simple name of the source file
    private final String sourceName;
    // pod name
    private final String pod;

    // once parse() is called, will contain the parboiled parsing result
    private ParsingResult<AstNode> parsingResult;
    private AstNode astRoot;
    // Cache types resolution, for performance
//    private HashMap<String, FanType> typeCache = new HashMap<String, FanType>();
    // Cache slots resolution, for performance
//    private HashMap<String, List<FanSlot>> typeSlotsCache = new HashMap<String, List<FanSlot>>();
    private FantomParser parser;

    private boolean localScopeDone;
    boolean hasGlobalError = false;

    Future<ParsingResult> parsingTask;
    CancellableRecoveringParserRunner<ParsingResult> runner;

    public FanParserTask(Snapshot snapshot) {
        super(snapshot);
        invalidated = false;
        sourceName = (snapshot == null || snapshot.getSource().getFileObject() == null)
                ? null
                : snapshot.getSource().getFileObject().getName();
        sourceFile = (snapshot == null || snapshot.getSource().getFileObject() == null)
                ? null
                : FileUtil.toFileObject(FileUtil.normalizeFile(new File(snapshot.getSource().getFileObject().getPath())));
        pod = (sourceFile == null) ? null : FanBuildFileHelper.getPodForPath(sourceFile.getPath());
        parser = Parboiled.createParser(FantomParser.class, this);
    }

    @Override
    public List<? extends Error> getDiagnostics() {
        return errors;
    }

    /**
     * Return parse node tree generated by this parsing
     *
     * @return
     */
    public Node<AstNode> getParseNodeTree() {
        if (parsingResult != null) {
            return parsingResult.parseTreeRoot;
        }
        return null;
    }

    public AstNode getAstTree() {
        Node<AstNode> nd = getParseNodeTree();
        return nd == null ? null : nd.getValue();
    }

    /**
     * Dump AST tree
     */
    public void dumpTree() {
        FanUtilities.logger.info("-------------------Start AST Tree dump-----------------------");
        ParseTreeUtils.printNodeTree(parsingResult);
        FanUtilities.logger.info("-------------------End AST Tree dump-----------------------");
    }

    /**
     * Shotcut method for getSnapshot().getSource().getDocument(true);
     *
     * @return
     */
    public Document getDocument() {
        return getSnapshot().getSource().getDocument(true);
    }

    public void addGlobalError(String title, Throwable t) {
        // "High level error"
        if (!(t instanceof CancellationException)) t.printStackTrace();
        Error error = DefaultError.createDefaultError(FanParserErrorKey.GLOBAL_ERROR.name(), title, title, null, 0, 0, true, Severity.ERROR);
        errors.add(error);
    }

    /**
     * The root scope
     *
     * @return
     */
    public AstNode getRootScope() {
        return astRoot;
    }

    public FileObject getSourceFile() {
        return sourceFile;
    }

    /**
     * Add an error (not the parser errors, but others like semantic etc..)
     *
     * @param info
     * @param node
     */
    public void addError(FanParserErrorKey key, String info, AstNode node) {
        if (node == null) {
            return;
        }
        String k = key.name();
        OffsetRange range = node.getRelevantTextRange();
        int start = range.getStart();
        int end = range.getEnd();
        //System.out.println("Start: "+start+"End:"+end);
        Error error = DefaultError.createDefaultError(k, info, "Syntax Error", sourceFile, start, end, true, Severity.ERROR);
        errors.add(error);
    }

    /**
     * Parse the file (using parboiled FantomParser)
     */
    @SuppressWarnings(value = "unchecked")
    public void parse(boolean quickScan, int msTimeout) {
        long start = System.currentTimeMillis();
        System.out.println("Starting parsing of: " + sourceName);

        parser.setQuickScan(quickScan);
        try {
            try {
                runner = new CancellableRecoveringParserRunner<ParsingResult>(parser.compilationUnit(),
                        getSnapshot().getText().toString(),
                        msTimeout);
                parsingTask = runner.start();
                parsingResult = parsingTask.get(msTimeout, TimeUnit.MILLISECONDS);
            } catch (TimeoutException e) {
                addGlobalError("Parsing of this file took too long and timed out.", e);
                return;
            } catch (ParserCancelledError e) {
                addGlobalError("Parsing was cancelled " + e, e);
                cleanup();
                return;
            } catch (CancellationException e) {
                addGlobalError("Parsing was cancelled. " + e, e);
                cleanup();
                return;
            } catch (ExecutionException e) {
                addGlobalError("Parsing execution failed " + e, e);
                cleanup();
                return;
            } catch (InterruptedException e) {
                addGlobalError("Parsing task was interrupted " + e, e);
                cleanup();
                return;
            } catch (Throwable e) {
                addGlobalError("Parsing error " + e, e);
                cleanup();
                Runtime.getRuntime().gc();
                return;
            }

            // Copy parboiled parse error into a CSL errrors
            for (ParseError err : parsingResult.parseErrors) {
                // key, displayName, description, file, start, end, lineError?, severity
                String msg = ErrorUtils.printParseError(err);
                Error error = DefaultError.createDefaultError(FanParserErrorKey.PARSER_ERROR.name(), msg, msg,
                        sourceFile, err.getStartIndex(), err.getEndIndex(),
                        false, Severity.ERROR);
                errors.add(error);
            }
            if (parsingResult.parseTreeRoot != null) {
                // link ast nodes together
                FantomParserAstActions.linkNodes(parsingResult.valueStack);
                astRoot = parsingResult.parseTreeRoot.getValue();
                //String parseTreePrintOut = ParseTreeUtils.printNodeTree(parsingResult);
            }
        } catch (Exception e) {
            addGlobalError("Parser error", e);
            e.printStackTrace();
            hasGlobalError = true;
        }

        FanUtilities.logger.info("Parsing completed in " + (System.currentTimeMillis() - start) + " for : " + sourceName);
    }

    private void cleanup() {
        if (parser != null) {
            boolean died = false;
            try {
                parser.cancel();
                Thread.sleep(1000);
            } catch (Exception e) {
                died = true;
                System.err.println("Parser was cancelled properly : " + e);
            }
            if (!died) {
                Context<AstNode> ctx = parser.getContext();
                System.err.println("Hum, parser still running, could be a runaway CPU hog!");
                System.err.println("Current path: " + ctx.getPath());
                System.err.println("Position: " + ctx.getPosition());
                System.err.println("Level: " + ctx.getLevel());
                System.err.println("InRecovery: " + ctx.inErrorRecovery() + ", InPred: " + ctx.inErrorRecovery() + ", NodeSupressed:" + ctx.isNodeSuppressed());
            }
        }
        if (parsingTask != null) {
            parsingTask.cancel(true);
        }
        parser = null;
    }

    /**
     * Call after parsing to add scope variables / type resolution to the AST
     * tree This does the "global" items - as needed by the indexer such as
     * types, slots & their params
     */
    @SuppressWarnings("unchecked")
    public void parseGlobalScope() {
        long start = new Date().getTime();
        FanUtilities.logger.fine("Starting parsing scope of: " + sourceName);
        if (astRoot == null) {
            return;
        }
        // First run : lookup using statements
        for (AstNode node : astRoot.getChildren()) {
            if (invalidated) {
                return; // bailing out if task cancelled
            }
            switch (node.getKind()) {
                case AST_INC_USING:
                    addError(FanParserErrorKey.INC_IMPORT, "Incomplete import statement", node);
                    break;

                case AST_USING:
                    addUsing(node);
                    break;

            }
        }

        // Second pass, lookup types and slots
        for (AstNode node : astRoot.getChildren()) {
            if (invalidated) {
                return; // bailing out if task cancelled
            }
            switch (node.getKind()) {
                case AST_TYPE_DEF:
                    String name = FanLexAstUtils.getFirstChildText(node, new NodeKindPredicate(AstKind.AST_ID), false);
                    if (name == null) {
                        break;
                    }
                    FanTypeScopeVar var = new FanTypeScopeVar(node, name);
                    AstNode scopeNode = FanLexAstUtils.getScopeNode(node.getRoot());
                    // We parse the type base first and add it to scope right away
                    // So that parseSlots() can later resolve this & super.
                    System.out.print(name);
                    var.parse();
                    Hashtable<String, FanAstScopeVarBase> vars = scopeNode.getAllScopeVars();
                    if (vars.containsKey(name)
                            && // If we have a "using" with the same name, we take precedence
                            vars.get(name).getKind() != VarKind.IMPORT
                            && vars.get(name).getKind() != VarKind.IMPORT_JAVA) {
                        addError(FanParserErrorKey.DUPLICATED_VAR, "Duplicated type name", node);
                    } else {
                        scopeNode.getLocalScopeVars().put(name, var);
                    }
                    // Parse the slot definitions
                    var.parseSlots(this);
                    break;
            }
        }

        if (dumpTree) {
            FanLexAstUtils.dumpTree(astRoot, 0);
        }
        FanUtilities.logger.info("Parsing of scope completed in " + (new Date().getTime() - start) + " for : " + sourceName);
    }
    //TODO: don't show the whole stack of errors, but just the base.
    // esp. for expressions, calls etc...

    /**
     * This parses the local scopes (inside slots) This is not needed by the
     * indexer, so we don't do it when called from the indexer (see NBFanParser)
     * It highlights errors as well
     */
    @SuppressWarnings("unchecked")
    public void parseLocalScopes() {
        // don't allow multiple calls
        synchronized (this) {
            if (localScopeDone) {
                return;
            }
            localScopeDone = true;
        }
        if (astRoot == null) {
            return;
        }
        // Now do all the local scopes / variables
        for (AstNode node : astRoot.getChildren()) {
            if (node.getKind() == AstKind.AST_TYPE_DEF) {
                for (FanAstScopeVarBase var : node.getLocalScopeVars().values()) {
                    if (var.getKind() == VarKind.CTOR || var.getKind() == VarKind.METHOD
                            && !(var instanceof FanLocalScopeVar)) // those are "generated" - no node to parse
                    {
                        if (invalidated) {
                            return; // bailing out if task cancelled
                        }
                        AstNode bkNode = var.getNode();
                        AstNode blockNode = FanLexAstUtils.getFirstChild(bkNode, new NodeKindPredicate(AstKind.AST_BLOCK));
                        if (blockNode != null) {
                            try {
                                parseVars(blockNode, null);
                            } catch (IllegalStateException e) {
                                return; // task cancelled
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Recursive - called by parseLocalScope Parse the blocks / expressions
     *
     * @param node
     * @param type
     */
    @SuppressWarnings("unchecked")
    public void parseVars(AstNode node, FanResolvedType type) {
        if (invalidated) {
            throw new IllegalStateException("Parser task was invalidated");
        }

        if (node == null) {
            return;
        }
        // If base type is unknown ... so are child
        if (type != null && type instanceof FanUnknownType) {
            node.setType(type);
            // Note: all children(if any) will be "unknown" as well.
            for (AstNode nd : node.getChildren()) {
                parseVars(nd, type);
            }
            return;
        }

        String text = node.getNodeText(true);
        try {
            switch (node.getKind()) {
                /*
                 * case TODO: AST_FIELD_ACCESSOR: AstNode fNode =
                 * FanLexAstUtils.findParentNode(node, AstKind.AST_FIELD_DEF);
                 * if (fNode != null) { AstNode fieldType =
                 * FanLexAstUtils.getFirstChild(fNode, new
                 * NodeKindPredicate(AstKind.AST_TYPE)); // introduce "it" to
                 * scope FanAstScopeVarBase itVar = new FanLocalScopeVar(node,
                 * VarKind.IMPLIED, "it", fieldType.getType());
                 * node.addScopeVar(itVar, true); } parseChildren(node); break;
                 */
                case AST_EXPR_INDEX:
                    AstNode indexEpr = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_EXPR));
                    type = doIndexExpr(indexEpr, type);
                    break;
                case AST_LIST:
                    // Index expressions, sometimes get parsed as Lists because the parser doesn't know a Type vs a variable
                    // so str[0] gets parsed as a list (like Str[0] would be) rather than an index expr
                    // so dolist takes care of that issue.
                    type = doList(node, type);
                    break;
                case AST_MAP:
                    type = doMap(node, type);
                    break;
                case AST_EXPR:
                case AST_EXPR_ASSIGN: // with the assignment we need reset type to null (start a new expression)
                case AST_EXPR_MULT:
                case AST_EXPR_ADD:
                    type = doExpr(node, type);
                    break;
                case AST_CALL_EXPR:
                    // there is also an operator node, but we ignore it - will be used in doCall()
                    AstNode callNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_CALL));
                    parseVars(callNode, type);
                    type = callNode.getType();
                    if (type == null || !type.isResolved()) {
                        // we need to exit now, because we already added an error in parseVars (don't want 2)
                        node.setType(type);
                        return;
                    }
                    break;
                case AST_CLOSURE:
                    // standalone closure -> closure definition
                    // closure calls are dealt with in doExpr
                    type = doClosureDef(node, null);
                    break;
                case AST_IT_BLOCK:
                // itBlocks that are not following a call or callExpr are in fact constructor block
                // the ones following call or callExpr are dealt with in doExpr as a closure
                // NO BREAK
                case AST_CTOR_BLOCK:
                    if (type == null) {
                        addError(FanParserErrorKey.UNEXPECTED_CTOR, "Unexpected constructor block", node);
                    }

                    doClosureCall(node, type, "with", 0);
                    type = type.asStaticContext(false);
                    break;
                case AST_CALL:
                    type = doCall(node, type, null);
                    break;
                case AST_ARG:
                    // arg contains one expression - parse it to check for errors
                    AstNode argExprNode = node.getChildren().get(0);
                    parseVars(argExprNode, null);
                    type = argExprNode.getType();
                    break;
                case AST_CHILD: // a wrapper node (takes type from wrapped node)
                    parseChildren(node);
                    if (node.getChildren().size() != 1) {
                        throw new RuntimeException("AST_CHILD should have only one child node");
                    }
                    type = node.getChildren().get(0).getType();
                    break;
                case AST_EXR_CAST:
                    // take the cast type
                    AstNode castTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
                    parseVars(castTypeNode, null);
                    type = castTypeNode.getType();
                    // then parse the expression separately
                    AstNode castExpr = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_EXPR));
                    parseVars(castExpr, null);
                    //TODO: check if cast is valid
                    break;
                case AST_EXPR_TYPE_CHECK:
                    type = doTypeCheckExpr(node, type);
                    break;
                case AST_EXPR_RANGE:
                    // if only one child, then it's really not a rangeExpr, but an addExpr
                    if (node.getChildren().size() == 1) {
                        parseVars(node.getChildren().get(0), type);
                        type = node.getChildren().get(0).getType();
                    } else {
                        type = doRangeExpr(node, type);
                    }
                    break;
                case AST_CATCH_BLOCK:
                    type = doCatchBlock(node, type);
                    break;
                case AST_EXPR_LIT_BASE:
                    //Node<AstNode> parseNode = node.getParseNode().getChildren().get(0); // firstOf
                    type = resolveLitteral(node);
                    break;
                case AST_ID:
                    type = FanResolvedType.makeFromTypeSig(node, text);
                    break;
                case AST_TYPE:
                    type = FanResolvedType.makeFromTypeSig(node, text);
                    break;
                case AST_LOCAL_DEF: // special case, since it introduces scope vars
                    type = doLocalDef(node, type);
                    break;
                case AST_TYPE_LITTERAL: // 'Type#' or '#slot' or 'Type#slot'
                    type = doTypeLitteral(node, type);
                    break;
                case AST_ENUM_DEFS:
                    // already dealt with in type/slot parsing
                    break;
                case AST_DSL:
                    AstNode dslType = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
                    parseVars(dslType, null);
                    type = dslType.getType();
                    break;
                case DUMMY_ROOT_NODE:
                    // have dummy_root_node (for testing) carry it's child type
                    AstNode dummyChild = node.getChildren().get(0);
                    parseVars(dummyChild, type);
                    type = dummyChild.getType();
                    break;
                default:
                    // recurse into children
                    parseChildren(node);
            }
        } catch (Exception e) {
            // We don't want exception to be propagated to user as an exception (prevents fixing it in IDE)
            // Do mark a global parsing error however
            type = FanResolvedType.makeUnresolved(node);
            addError(FanParserErrorKey.PARSING_ERR, "Unexpected Parsing error: " + e.toString(), node);
            FanUtilities.logger.throwing("Error parsing node: " + text, "parseVars", e);
        }
        node.setType(type);
        if (type != null && !type.isResolved()) {
            addError(FanParserErrorKey.UNKNOWN_ITEM, "Could not resolve item -> " + text, node);

            //FanUtilities.logger.info(">Unresolved node");
            //FanLexAstUtils.dumpTree(node, 0);
            //FanLexAstUtils.dumpTree(astRoot, 0);
            //FanUtilities.logger.info("<Unresolved node");
        }
    }

    private void parseChildren(AstNode node) {
        for (AstNode child : node.getChildren()) {
            parseVars(child, null);
        }
    }

    public FanResolvedType resolveLitteral(AstNode astNode) {
        FanResolvedType type = FanResolvedType.makeUnresolved(astNode);
        String lbl = astNode.getLabel();
        String txt = astNode.getNodeText(true);
        if (lbl.equalsIgnoreCase(TokenName.ID.name())) {
            type = FanResolvedType.makeFromTypeSig(astNode, txt);
        } else if (lbl.equalsIgnoreCase(TokenName.CHAR_.name())) {
            type = FanResolvedType.makeFromTypeSig(astNode, "sys::Int");
        } else if (lbl.equalsIgnoreCase(TokenName.NUMBER.name())) {
            char lastChar = (txt == null || txt.length() == 0) ? null : txt.charAt(txt.length() - 1);
            if (txt.toLowerCase().startsWith("0x")) {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Int");
            } else if (lastChar == 'f' || lastChar == 'F') {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Float");
            } else if (lastChar == 'd' || lastChar == 'D') {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Decimal");
            } else if (txt.endsWith("day") || txt.endsWith("hr") || txt.endsWith("min") || txt.endsWith("sec") || txt.endsWith("ms") || txt.endsWith("ns")) {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Duration");
            } else if (txt.indexOf(".") != -1) {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Float");
            } else {
                type = FanResolvedType.makeFromTypeSig(astNode, "sys::Int"); // Default
            }
        } else if (lbl.equalsIgnoreCase(TokenName.STRS.name())) {
            type = FanResolvedType.makeFromTypeSig(astNode, "sys::Str");
        } else if (lbl.equalsIgnoreCase(TokenName.URI.name())) {
            type = FanResolvedType.makeFromTypeSig(astNode, "sys::Uri");
        } else if (lbl.equals("true") || lbl.equals("false")) {
            type = FanResolvedType.makeFromTypeSig(astNode, "sys::Bool");
        } else if (lbl.equals("null")) {
            type = new FanResolvedNullType(astNode);
            // null is always nullable :)
            type = type.asNullableContext(true);
        } else if (lbl.equals("it")) {
            FanAstScopeVarBase var = astNode.getAllScopeVars().get("it");
            if (var != null) {
                type = var.getType();
            }
        } else if (lbl.equals("this")) {
            type = FanResolvedType.resolveThisType(astNode);
        } else if (lbl.equals("super")) {
            type = FanResolvedType.resolveSuper(astNode);
        }
        // Literal are never static context
        return type.asStaticContext(false);
    }

    @SuppressWarnings("unchecked")
    private void addUsing(AstNode usingNode) {
        String type = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_ID), false);
        String as = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_USING_AS), true);
//        String ffi = FanLexAstUtils.getFirstChildText(usingNode, new NodeKindPredicate(AstKind.AST_USING_FFI), true);

        String name = as != null ? as : type;
        if (name.indexOf("::") > -1) {
            name = name.substring(name.indexOf("::") + 2);
        }

        if (type.indexOf("::") > 0) {
            // Adding a specific type
            String[] data = type.split("::");
            if (!Namespace.get().hasPod(data[0])) {
                addError(FanParserErrorKey.UNRESOLVED_USING, "Unresolved Pod: " + data[0], usingNode);
            } else if (Namespace.get().findByQualifiedName(type) == null) {
                addError(FanParserErrorKey.UNRESOLVED_USING, "Unresolved Type: " + type, usingNode);
            }

            //Type t = FanPodIndexer.getInstance().getPodType(data[0], data[1]);
            addUsingToNode(name, type, usingNode, VarKind.IMPORT);
        } else {
            // Adding all the types of a Pod
            if (name.equalsIgnoreCase("sys")) // sys is always avail.
            {
                return;
            }
            if (!Namespace.get().hasPod(name)) {
                addError(FanParserErrorKey.UNRESOLVED_USING, "Unresolved Pod: " + name, usingNode);
            } else {
                List<FanType> items = Namespace.get().findPodTypes(name);
                for (FanType t : items) {
                    addUsingToNode(t.getSimpleName(), t.getQualifiedName(), usingNode, VarKind.IMPORT);
                }
            }
        }
    }

    public static void addUsingToNode(String name, String qType, AstNode node, VarKind importKind) {
        AstNode scopeNode = FanLexAstUtils.getScopeNode(node);
        if (scopeNode == null) {
            return;
        }
        if (scopeNode.getLocalScopeVars().containsKey(name)) {
            // This is 'legal' ... maybe show a warning later ?
            //addError("Duplicated using: " + qType + " / " + scopeNode.getLocalScopeVars().get(name), node);
            System.out.println("Already have a using called: " + qType + " (" + scopeNode.getLocalScopeVars().get(name) + ")");
            // Note: only keeping the 'last' definition (ie: override)
        }
        FanResolvedType rType = FanResolvedType.makeFromDbType(node, qType);
        rType = rType.asStaticContext(true);
        scopeNode.addScopeVar(name, importKind, rType, true);
    }

    public ParsingResult<AstNode> getParsingResult() {
        return parsingResult;
    }

    public String getPod() {
        return pod;
    }

    /**
     * TODO: this whole prunning stuff is a bit ugly Should try to buod the AST
     * properly using technizues here:
     * http://parboiled.hostingdelivered.com/viewtopic.php?f=3&t=9
     *
     * During ParseNode construction, some astNodes that migth have been
     * constructed from some parseNode that where then "backtracked" (not the
     * whoel sequence matched) This looks for and remove those unwanted nodes.
     *
     * @param node
     */
    /*
     * public void prune(AstNode node, String rootLabel) { List<AstNode>
     * children = node.getChildren(); List<AstNode> toBepruned = new
     * ArrayList<AstNode>(); for (AstNode child : children) { Node<AstNode>
     * parseNode = child.getParseNode(); // If the node is orphaned (no link
     * back to the root), that means it was backtracked out of. String label =
     * "N/A"; while (parseNode != null) { label = parseNode.getLabel();
     * parseNode = parseNode.getParent(); } if (!rootLabel.equals(label)) {
     * toBepruned.add(child); } else { // recurse into children prune(child,
     * rootLabel); } } // Drop the orphaned nodes for (AstNode nd : toBepruned)
     * { children.remove(nd); } } public String getRootLabel(AstNode rootNode) {
     * Node<AstNode> parseNode = rootNode.getParseNode(); String rootLabel =
     * "n/a"; while (parseNode != null) { rootLabel = parseNode.getLabel();
     * parseNode = parseNode.getParent(); } return rootLabel; }
     */
    @SuppressWarnings("unchecked")
    private FanResolvedType doExpr(AstNode node, FanResolvedType type) {
        // TODO: validate assignment type is compatible.
        boolean first = true;
        type = null;
        List<AstNode> children = node.getChildren();
        for (int i = 0; i != children.size(); i++) {
            FanResolvedType baseType = type != null ? type : FanResolvedType.resolveItType(node);
            // when a itBlock follows a call, it's actually a sort of closure call (with block)
            AstNode child = children.get(i);
            if (child.getKind() == AstKind.AST_CALL || child.getKind() == AstKind.AST_CALL_EXPR) {
                if (i + 1 < children.size()) {
                    AstNode nextChild = children.get(i + 1);
                    if (nextChild.getKind() == AstKind.AST_IT_BLOCK) {
                        AstNode callChild = child.getKind() == AstKind.AST_CALL
                                ? child
                                : FanLexAstUtils.getFirstChild(child, new NodeKindPredicate(AstKind.AST_CALL)); // call expr
                        // parse the whole thing as a closure call
                        type = doCall(callChild, type, nextChild);
                        // skip next child since we juts did it
                        i++;
                        continue;
                    }
                }
            }
            // Other special case of closure called on local method  like "method{....}"
            // get misunderstood as a constructor block
            FanResolvedType thisType = FanResolvedType.resolveThisType(node);
            boolean isSlot = child.getKind() == AstKind.AST_ID
                    && thisType.resolveSlotType(child.getNodeText(true), this).isResolved();
            if (isSlot) {
                if (i + 1 < children.size()) {
                    AstNode nextChild = children.get(i + 1);
                    if (nextChild.getKind() == AstKind.AST_CTOR_BLOCK) {
                        // parse the whole thing as a closure call
                        type = doCall(node, thisType, nextChild);
                        // skip next child since we juts did it
                        i++;
                        continue;
                    }
                }
            }

            // Normal procedure
            parseVars(child, type);
            // we take type of right hand side if first in expression
            // and not one of the special type we don't want the rhs for
            if (first || (child.getKind() != AstKind.AST_EXPR_ADD // add/mult operation cannot change the type
                    && child.getKind() != AstKind.AST_EXPR_MULT //same
                    /*
                     * && child.getKind() != AstKind.AST_EXPR
                     */)) // new/sub expression
            {
                type = child.getType();
                if (type != null && type.isResolved()) {
                    type = type.parameterize(baseType, child);
                }
                // If part of the expr chain is unresolved (error), mark it unresolved
                // This avoids getting errors for the whole expression chain
                if (type != null && !type.isResolved()) {
                    type = new FanUnknownType(node, child.getNodeText(true));
                }
            }
            first = false;
        }
        return type;
    }

    /**
     *
     * @param node
     * @param type
     * @param forcedClosure : when we have an itBlock, we need to send it as if
     * it was a closure
     * @return
     */
    @SuppressWarnings("unchecked")
    private FanResolvedType doCall(AstNode node, FanResolvedType type, AstNode forcedClosure) {
        // saving the base type, because we need it for closures
        FanResolvedType baseType = type;
        if (type != null && type.isResolved()
                && node.getNodeText(true).equals("super")) {	// named super.
            if (!type.isStaticContext()
                    || !FanResolvedType.resolveThisType(node).isTypeCompatible(type)) {
                addError(FanParserErrorKey.INAVALID_SUPER, "Invalid named super call", node);
                type = FanResolvedType.makeUnresolved(node);
            } else {
                type = type.asStaticContext(false);
            }
            return type;
        }

        AstNode callChild = node.getChildren().get(0);
        String name = callChild.getNodeText(true);

        //if a direct call like doThis(), then search scope for type/slot
        // or if the type is actualy the current type we are in (that happens when using 'this.')
        if (type == null || type.isSameAsThisType(node)) {
            baseType = FanResolvedType.resolveItType(callChild);
            // constructor call or local slot
            type = FanResolvedType.makeFromTypeSig(callChild, name);
            type = type.parameterize(baseType, callChild).asStaticContext(false); // call is always not staticContext
            FanAstScopeVarBase childVar = callChild.getAllScopeVars().get(callChild.getNodeText(true));
            // If not in scope, then not a local slot.
            if (childVar == null || (childVar.getKind() != VarKind.FIELD && childVar.getKind() != VarKind.METHOD)) { // It was a constructor call
                // once we make the call to make, it's not staticContext anymore
                baseType = type.asStaticContext(false);
                name = "make";
            }
        }
        else // otherwise a slot of the base type like var.toStr()
        {
            // checking what call op we are dealing with
            String op = ".";
            AstNode callExpr = FanLexAstUtils.findParentNode(node, AstKind.AST_CALL_EXPR);
            if (callExpr != null) {
                AstNode operator = FanLexAstUtils.getFirstChild(callExpr, new NodeKindPredicate(AstKind.LBL_OP));
                if (operator != null) {
                    op = operator.getNodeText(true);
                }
            }
            // Can't resolve dynamic calls -> unknow type
            if (op.endsWith("->")) {
                return new FanUnknownType(node, sourceName);
            }

            // If using null check call on non nullable object, show an error, but continue resolution
            if (!type.isNullable() && op.startsWith("?")) {
                addError(FanParserErrorKey.NULL_CHECK, "Null check call on non-nullable: " + type.toString(), node);
            }

            type = type.resolveSlotType(name, this);
            type = type.parameterize(baseType, node);
            type = type.asStaticContext(false); // result of call never staticContext

            // The result of a null check call is always a nullable.
            // Note call like doc?.do comes as doc? . do
            if (op.startsWith("?")) {
                type = type.asNullableContext(true);
            }
        }

        // parse args
        List<AstNode> args = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_ARG));
        int argIndex = 0;
        for (AstNode arg : args) {
            if (FanLexAstUtils.isWrappingNode(arg, new NodeKindPredicate(AstKind.AST_CLOSURE))) {
                // If the argument is a closure, we need to call doClosure directly
                AstNode closure = FanLexAstUtils.getFirstChildRecursive(arg, new NodeKindPredicate(AstKind.AST_CLOSURE));
                doClosureCall(closure, baseType, name, argIndex);
            } else {
                // otherwise, do normal parsing
                parseVars(arg, null);
            }
            argIndex++;
        }

        // deal with the special trailing closure argument (if any)
        // TODO: Check that param types matches slot declaration
        AstNode closure = forcedClosure != null ? forcedClosure : FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_CLOSURE));
        if (closure != null) {
            doClosureCall(closure, baseType, name, argIndex);
        }
        // we need to parameterize the result
        // if baseType is null, then it probably couldn't return generics and if it did, then it would be "this", so leave it alone either way
        if (baseType != null) {
            type = type.parameterize(baseType, node);
        }
        return type.asStaticContext(false);
    }

    private void doClosureCall(AstNode closureNode, FanResolvedType baseType, String slotName, int argIndex) {
        //TODO: Check that param types matches slot declaration
        FanResolvedType slotBase = baseType.resolveSlotBaseType(slotName, this);
        FanSlot slot = FanSlot.findByTypeAndName(slotBase.getQualifiedType(), slotName);
        if (slot == null) {
            addError(FanParserErrorKey.CLOSURE_CALL, "Can't find closure call slot: " + slotBase.getQualifiedType() + "." + slotName, closureNode);
        } else {
            List<FanMethodParam> params = slot.getAllParameters();
            if (argIndex > params.size()) {
                addError(FanParserErrorKey.CLOSURE_CALL, "Too many parameters in closure call.", closureNode);
            } else {
                if (argIndex == params.size()) {
                    // One extra parameter VS expected -> trying 'with' call
                    slotBase = baseType.resolveSlotBaseType("with", this);
                    slot = FanSlot.findByTypeAndName(slotBase.getQualifiedType(), "with");
                    params = slot.getAllParameters();
                    argIndex = 0;
                }
                FanResolvedType func = FanResolvedType.makeFromTypeSig(closureNode, params.get(argIndex).getQualifiedType());
                if (func == null || !(func instanceof FanResolvedFuncType)) {
                    // This could happen, because of defaulted parameters, try a 'with' as well then .. probably too loose
                    slotBase = baseType.resolveSlotBaseType("with", this);
                    slot = FanSlot.findByTypeAndName(slotBase.getQualifiedType(), "with");
                    params = slot.getAllParameters();
                    argIndex = 0;
                    func = FanResolvedType.makeFromTypeSig(closureNode, params.get(argIndex).getQualifiedType());
                }
                // build lits of expected params for doClosure to use for inferrence resolution
                List<FanResolvedType> infTypes = new ArrayList<FanResolvedType>();
                if (func instanceof FanResolvedFuncType) { // Otherwise it's a generic sys::Func -> no inference possible
                    for (FanResolvedType t : ((FanResolvedFuncType) func).getTypes()) {
                        // might be a generic type
                        t = t.parameterize(baseType, closureNode);
                        infTypes.add(t);
                    }
                }

                FanResolvedFuncType closureFunc = closureNode.getKind() == AstKind.AST_CLOSURE
                        ? doClosureDef(closureNode, infTypes)
                        : (FanResolvedFuncType) func;

                AstNode closureBlock = closureNode.getKind() == AstKind.AST_CLOSURE
                        ? FanLexAstUtils.getFirstChild(closureNode, new NodeKindPredicate(AstKind.AST_BLOCK))
                        : closureNode;

                // introduce the function variables
                boolean anyVars = false;
                if (closureFunc.getTypeNames() != null) {
                    for (int i = 0; i != closureFunc.getTypeNames().size(); i++) {
                        String name = closureFunc.getTypeNames().get(i);
                        FanResolvedType type = closureFunc.getTypes().get(i);
                        if (name != null) {
                            closureBlock.addScopeVar(name, VarKind.LOCAL, type, false);
                            anyVars = true;
                        }
                    }
                }
                if (anyVars == false) {
                    FanResolvedType varType = closureFunc.getTypes().size() > 0
                            ? closureFunc.getTypes().get(0).parameterize(baseType, closureNode)
                            : baseType;
                    introduceItVariables(closureBlock, varType);	// parse the block
                }
                parseChildren(closureBlock);
            }
        }
    }

    /**
     *
     * @param closureDefNode, can be null if not a closure defintion (itBlock /
     * ctorblock)
     * @param blockNode
     * @param paramTypes
     * @return
     */
    @SuppressWarnings("unchecked")
    private FanResolvedFuncType doClosureDef(AstNode closureDefNode, List<FanResolvedType> paramTypes) {
        FanResolvedType retType = FanResolvedType.makeFromDbType(closureDefNode, "sys::Void").asStaticContext(false);
        FanResolvedFuncType result = null;
        // Will store resolved types
        List<FanResolvedType> formalTypes = new ArrayList<FanResolvedType>();
        int index = 0;
        List<String> formalNames = new ArrayList<String>();
        if (closureDefNode != null) {	// fully qualified closure (with parameters)
            for (AstNode child : closureDefNode.getChildren()) {
                if (child.getKind() == AstKind.AST_FORMAL) {
                    GenericPair<String, FanResolvedType> pair = doFormal(child, paramTypes, index);
                    FanResolvedType t = pair.getSecond();
                    if (t != null && !t.isResolved()) {
                        addError(FanParserErrorKey.FORMAL_DEF, "Couldn't resolve formal definition: " + child.getNodeText(true), child);
                    }
                    String name = pair.getFirst();
                    formalTypes.add(t);
                    formalNames.add(name);
                } else if (child.getKind() == AstKind.AST_TYPE) {
                    // save the returned type
                    parseVars(child, null);
                    retType = child.getType();
                }
                index++;
            }
            result = new FanResolvedFuncType(closureDefNode, formalTypes, retType);
            result.setTypeNames(formalNames);
        } else {
            formalTypes.add(FanResolvedType.makeFromDbType(null, "sys::This"));
            result = new FanResolvedFuncType(null, formalTypes, FanResolvedType.makeFromDbType(null, "sys::Void"));
        }
        return result;
    }

    /**
     * Deal with a formal (as used in a call)
     *
     * @param node
     * @param baseType
     * @param closureBlock
     * @param formalTypes
     * @param index
     * @return
     */
    @SuppressWarnings("unchecked")
    private GenericPair<String, FanResolvedType> doFormal(AstNode node, List<FanResolvedType> inferredTypes, int index) {
        AstNode formalName = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_ID));
        AstNode formalTypeAndId = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE_AND_ID));
        FanResolvedType fType = FanResolvedType.makeFromDbType(node, "sys::Void").asStaticContext(false);
        if (formalTypeAndId != null) {	// typed formal
            formalName = FanLexAstUtils.getFirstChild(formalTypeAndId, new NodeKindPredicate(AstKind.AST_ID));
            AstNode formalType = FanLexAstUtils.getFirstChild(formalTypeAndId, new NodeKindPredicate(AstKind.AST_TYPE));
            parseVars(formalType, null);
            fType = formalType.getType().asStaticContext(false);
            // TODO: check that it matches callParams
        } else {
            if (inferredTypes == null) {
                //addError("Can't have inferred formals in closure definition.", node);
                // actually that's allowed, just uses sys::Obj?
                fType = FanResolvedType.makeFromTypeSig(node, "sys::Obj?");
            } else if (index >= inferredTypes.size()) {
                addError(FanParserErrorKey.FORMAL_DEF, "More inferred formals than expected.", node);
                fType = FanResolvedType.makeUnresolved(node);
            } else {
                fType = inferredTypes.get(index);
            }
        }

        return new GenericPair<String, FanResolvedType>(formalName == null ? null : formalName.getNodeText(true), fType);
    }

    /**
     * Index expressions, sometimes get parsed as Lists because the parser
     * doesn't know a Type vs a variable so str[0] gets parsed as a list (like
     * Str[0] would be) rather than an index expr So we deal with this here.
     *
     * @param node
     * @param type
     * @return
     */
    @SuppressWarnings("unchecked")
    private FanResolvedType doList(AstNode node, FanResolvedType type) {
        AstNode listTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
        List<AstNode> listExprNodes = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_EXPR));
        List<FanResolvedType> listTypes = new ArrayList<FanResolvedType>();
        if (listTypeNode != null) {   // if it's a typed list, use that as the type
            parseVars(listTypeNode, null);
            if (!listTypeNode.getType().isStaticContext() && listExprNodes.size() > 0) {
                // It's NOT a List at all after all, but an index expression (called on a var, not a Static type)!
                return doIndexExpr(listExprNodes.get(0), listTypeNode.getType());
            }

            type = new FanResolvedListType(node,
                    listTypeNode.getType());
        }

        for (AstNode listExpr : listExprNodes) {
            parseVars(listExpr, null);
            listTypes.add(listExpr.getType());
        }
        if (listTypeNode == null) {   // try to infer it from the expr Nodes
            type = new FanResolvedListType(node,
                    FanResolvedType.makeFromItemList(node, listTypes));
        }
        return type;
    }

    @SuppressWarnings("unchecked")
    private FanResolvedType doMap(AstNode node, FanResolvedType type) {
        AstNode mapTypeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
        List<AstNode> mapPairNodes = FanLexAstUtils.getChildren(node, new NodeKindPredicate(AstKind.AST_MAP_PAIR));
        List<FanResolvedType> mapKeyTypes = new ArrayList<FanResolvedType>();
        List<FanResolvedType> mapValTypes = new ArrayList<FanResolvedType>();
        for (AstNode mapPair : mapPairNodes) {
            AstNode mapKey = mapPair.getChildren().get(0);
            AstNode mapVal = mapPair.getChildren().get(1);
            parseVars(mapKey, null);
            parseVars(mapVal, null);
            mapKeyTypes.add(mapKey.getType());
            mapValTypes.add(mapVal.getType());
        }
        if (mapTypeNode != null) {   // if it's a typed list, use that as the type
            parseVars(mapTypeNode, null);
            type = mapTypeNode.getType();
        } else { // otherwise try to infer it from the expr Nodes
            type = new FanResolvedMapType(node,
                    FanResolvedType.makeFromItemList(node, mapKeyTypes),
                    FanResolvedType.makeFromItemList(node, mapValTypes));
        }
        return type;
    }

    /**
     * Note that we get the content of the index expression (exprNode)
     *
     * @param exprNode
     * @param type
     * @return
     */
    @SuppressWarnings("unchecked")
    private FanResolvedType doIndexExpr(AstNode exprNode, FanResolvedType type) {
        FanResolvedType baseType = type;
        parseVars(exprNode, null);
        AstNode range = FanLexAstUtils.getFirstChildRecursive(exprNode, new NodeKindPredicate(AstKind.AST_EXPR_RANGE));
        // It's kinda twisted, but the expr will have a range ast node either way
        // however in the case of a "real" range it has 2 children expr (otherwise just 1 expr)
        if (range != null && range.getChildren().size() == 2) {
            // in case of a range, it's a call to getRange()
            type = type.resolveSlotType("getRange", this);
            if (!type.isResolved()) {
                addError(FanParserErrorKey.RANGE, "Range expression only valid on types with a 'getRange' method." + exprNode.getNodeText(true), exprNode);
            }
        } else {
            // otherwise to get() (including list/maps)
            type = type.resolveSlotType("get", this);
            if (!type.isResolved()) {
                addError(FanParserErrorKey.INDEX, "Index expression only valid on types with 'get' method-> " + exprNode.getNodeText(true), exprNode);
            }
        }

        // TODO: check if list/map index key type is valid ?
        return type.parameterize(baseType, exprNode).asStaticContext(false);
    }

    @SuppressWarnings("unchecked")
    private FanResolvedType doTypeCheckExpr(AstNode node, FanResolvedType type) {
        String text = node.getNodeText(true);
        parseChildren(node);
        AstNode checkType = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
        if (text.startsWith("as")) // (cast)
        {
            type = checkType.getType();
        } else if (text.startsWith("is")) // is or isnot	-> boolean
        {
            type = FanResolvedType.makeFromDbType(node, "sys::Bool");
        } else {
            type = null; // shouldn't happen
        }
        return type.asStaticContext(false);
    }

    private void introduceItVariables(AstNode node, FanResolvedType itType) {
        if (itType != null && itType.getDbType() != null) {
            itType = itType.asStaticContext(false);
            List<FanSlot> itSlots = itType.getDbType().getAllSlots();
            Hashtable<String, FanAstScopeVarBase> curvars = node.getAllScopeVars();
            for (FanSlot itSlot : itSlots) {
                // itVar cannot "take over" existing variables
                if (!curvars.containsKey(itSlot.getName())) {
                    FanAstScopeVarBase newVar = new FanLocalScopeVar(node, itType, itSlot, itSlot.getName());
                    node.addScopeVar(newVar, false);
                }
            }
            // add "it" to scope
            FanAstScopeVarBase itVar = new FanLocalScopeVar(node, VarKind.IMPLIED, "it", itType);
            node.addScopeVar(itVar, true);
        }
    }

    @SuppressWarnings("unchecked")
    private FanResolvedType doLocalDef(AstNode node, FanResolvedType type) {
        AstNode typeAndIdNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE_AND_ID));
        AstNode idNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_ID));
        AstNode exprNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_EXPR));
        if (typeAndIdNode != null) {
            idNode = FanLexAstUtils.getFirstChild(typeAndIdNode, new NodeKindPredicate(AstKind.AST_ID));
            AstNode typeNode = FanLexAstUtils.getFirstChild(typeAndIdNode, new NodeKindPredicate(AstKind.AST_TYPE));
            parseVars(typeNode, null);
            type = typeNode.getType();
        }

        String name = idNode.getNodeText(true);

        if (exprNode != null) {
            parseVars(exprNode, null);
            if (type == null) // Prefer the type in TypeNode if specified
            {
                type = exprNode.getType();
                //TODO: check types are compatible
            }
        }
        if (type != null) {
            type = type.asStaticContext(false);
        }
        node.addScopeVar(new FanLocalScopeVar(node, VarKind.LOCAL, name, type), false);
        return type;
    }

    private FanResolvedType doRangeExpr(AstNode node, FanResolvedType type) {
        parseChildren(node);
        if (type == null) {
            // a range like (0..5) - always a range of Int
            type = FanResolvedType.makeFromDbType(node, "sys::Range");
        } else if (type instanceof FanResolvedListType) {
            // a range like list[0..5]
            type = ((FanResolvedListType) type).getItemType().asStaticContext(false);
        } else if (type instanceof FanResolvedMapType) {
            // a range like map[0..5]
            type = ((FanResolvedMapType) type).getValType().asStaticContext(false);
        } else {
            // a range like "mystring"[0..5]
            type = type.resolveSlotType("getRange", this);
        }
        return type;
    }

    @SuppressWarnings("unchecked")
    private FanResolvedType doCatchBlock(AstNode node, FanResolvedType type) {
        AstNode typeNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_TYPE));
        AstNode idNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_ID));
        AstNode blockNode = FanLexAstUtils.getFirstChild(node, new NodeKindPredicate(AstKind.AST_BLOCK));
        if (typeNode != null && idNode != null && blockNode != null) {
            parseVars(typeNode, null);
            // add exception variable to block scope
            FanAstScopeVarBase itVar = new FanLocalScopeVar(node, VarKind.LOCAL, idNode.getNodeText(true), typeNode.getType().asStaticContext(false));
            blockNode.addScopeVar(itVar, true);
            // Now parse the block
            parseVars(blockNode, null);
        }
        return type;
    }

    /**
     * Resolves fanType for a qualified name Uses a cache for performance reason
     * (heavy DB actions). Calls FanType.findByQualifiedName(qName)
     *
     * @param qName
     * @return
     */
//    public FanType findCachedQualifiedType(String qName) {
//        if (!typeCache.containsKey(qName)) {
//            typeCache.put(qName, Namespace.get().findByQualifiedName(qName));
//        }
//        return typeCache.get(qName);
//    }
//
//    public HashMap<String, List<FanSlot>> getTypeSlotCache() {
//        return typeSlotsCache;
//    }
    private FanResolvedType doTypeLitteral(AstNode node, FanResolvedType type) {
        FanResolvedType baseType = type;
        String slotId = node.getNodeText(true).substring(1); // always starts with #
        boolean isTypeLit = type != null && slotId.length() == 0; // otherwise a slot
        type = FanResolvedType.makeUnresolved(node);
        if (isTypeLit) {
            type = FanResolvedType.makeFromDbType(node, "sys::Type");
        } else {// slot litteral
            // Fantom types
            if (baseType == null) {
                // local slot
                FanAstScopeVarBase var = node.getAllScopeVars().get(slotId);
                if (var instanceof FanMethodScopeVar) // note: method inherits from field
                {
                    type = FanResolvedType.makeFromDbType(node, "sys::Method");
                } else {
                    type = FanResolvedType.makeFromDbType(node, "sys::Field");
                }
            } else {
                // Type specified slots
                FanSlot slot = FanSlot.findByTypeAndName(baseType.getQualifiedType(), slotId);
                if (slot != null) {
                    if (slot.isField()) {
                        type = FanResolvedType.makeFromDbType(node, "sys::Field");
                    } else {
                        type = FanResolvedType.makeFromDbType(node, "sys::Method");
                    }
                }
            }
        }
        // we want an instance of the type
        type = type.asStaticContext(false);
        return type;
    }

    @Override
    protected void invalidate() {
        cancel();
    }

    void cancel() {
        //System.out.println("Parser cancel called");
        if (parsingTask != null) {
            parsingTask.cancel(true);
        }
        if (parser != null) {
            // TODO: this seem to cause crashes/deadlock
            parser.cancel();
            parser = null;
        }
    }

    public boolean hasGlobalError() {
        return hasGlobalError;
    }
}
